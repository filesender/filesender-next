// Package archive contains implementation for zipping / archiving files into a temporary archive
package archive

import (
	"archive/zip"
	"io"
	"log/slog"
	"os"
	"path/filepath"
	"strings"

	"codeberg.org/filesender/filesender-next/internal/id"
)

var tempDirPath string

// Init initialises the archive directory with the temporary directory path generated by main
func Init(_tempDirPath string) {
	tempDirPath = _tempDirPath
}

// ZipTransfer zips all files in a directory into a temporary .zip file
func ZipTransfer(source string) (string, error) {
	randomStr, err := id.New()
	if err != nil {
		slog.Error("Failed creating random string", "error", err)
		return "", err
	}

	zipFilePath := filepath.Join(tempDirPath, randomStr+".zip")
	zipFile, err := os.Create(zipFilePath)
	if err != nil {
		slog.Error("Failed creating new file", "error", err)
		return "", err
	}
	defer func() {
		if err := zipFile.Close(); err != nil {
			slog.Error("Failed closing file", "error", err)
		}
	}()

	zipWriter := zip.NewWriter(zipFile)
	defer func() {
		if err := zipWriter.Close(); err != nil {
			slog.Error("Failed closing zip writer", "error", err)
		}
	}()

	err = filepath.WalkDir(source, func(path string, d os.DirEntry, err error) error {
		if err != nil {
			slog.Error("Failed walking directory", "error", err)
			return err
		}

		if path == source {
			return nil
		}

		relPath, err := filepath.Rel(source, path)
		if err != nil {
			slog.Error("Failed getting relative path", "error", err)
			return err
		}
		relPath = filepath.ToSlash(relPath)

		if d.IsDir() {
			_, err := zipWriter.Create(relPath + "/")
			if err != nil {
				slog.Error("Failed creating directory to zip", "error", err)
			}

			return err
		}

		fileName := filepath.Base(path)
		fileNameParts := strings.Split(fileName, ".")
		if len(fileNameParts) >= 3 && fileNameParts[len(fileNameParts)-1] == "meta" {
			// The file is a `.meta` file, we want to skip that
			return nil
		}

		file, err := os.Open(path)
		if err != nil {
			slog.Error("Failed opening file", "error", err)
			return err
		}
		defer func() {
			if err := file.Close(); err != nil {
				slog.Error("Failed closing file", "error", err)
			}
		}()

		fw, err := zipWriter.Create(relPath)
		if err != nil {
			slog.Error("Failed creating new file in zip archive", "error", err)
			return err
		}

		_, err = io.Copy(fw, file)
		return err
	})
	if err != nil {
		slog.Error("Failed writing zip file", "error", err)
		return "", err
	}

	return zipFilePath, nil
}
